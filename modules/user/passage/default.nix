
# Metamodule that can create a matching home-manager module for reading secrets via passage
# and devShell module for editing secrets in the repository
{secrets ? {}, flakeRoot} :
  let
    mkCommon = ({pkgs,lib, ...}: with lib; {

      # Create tiny wrapper script that allows calling rage as age
      # Creating a separate derivation avoids rebuilding rage which would happen if modifying rage's postInstall
      # Replacing age with rage to allow passage to use its benefits like custom graphical pinentry
      rage-as-age = pkgs.stdenv.mkDerivation {
        name = "rage-as-age";
        buildInputs = [ pkgs.rage ];
        nativeBuildInputs = [ pkgs.makeWrapper ];
        unpackPhase = "true";
        installPhase = ''
          mkdir -p "$out/bin"
          makeWrapper ${pkgs.rage}/bin/rage $out/bin/age
        '';
      };

      # Make passage use our rage-as-age shim
      passage-with-rage = pkgs.passage.override { age = rage-as-age;};

      # Force passage to default to the correct directory and identity file from the nix store
      # Only decryption is needed since passage is pointed at the read-only nix store
      # Encryption is not possible by design, adding or editing passwords should only be done via git commits/nix switch

      # Using "--set-default" still allows using passage with other stores and identitiy by setting PASSAGE_DIR and PASSAGE_IDENTITIES_FILE
      passage-wrapped = passage-with-rage.overrideAttrs (attrs: {
        postInstall = (
          strings.concatMapStringsSep "\n"
          (x: if strings.hasInfix "wrapProgram" x then
                x+ " --set-default PASSAGE_DIR ${../../../secrets/passage/joel} --set-default PASSAGE_IDENTITIES_FILE ${../../../age-identities/age-yubikey-5c-primary-identity-c8d44732.pub}"
              else
                x
          )
          (strings.splitString "\n" attrs.postInstall)
        );
      });

      options = {
        secrets = {
          enable = mkEnableOption "user secret store based on passage";

          masterIdentityFile = mkOption {
            type = with types; coercedTo path toString str;
            description = ''
              Path to an age identity File.
              This should be a string describing an absolute path to the identity file on the system and not in the nix store.
              Important: Only use a path copied into the nix store, if the identity file is split file (i.e. yubikey)
              or protected with a strong password.

              As a precaution, this module will cause a warning if the coerced path is an absolute path inside the nix store
              and does not end in ".pub" or ".age" (which would indicate a split identity or password-protected identity respectively).
              (Inspired by `agenix-rekey`'s handling of identities).

              By default this will be the only identity configured to decrypt the secrets. For disaster recovery,
              a backup identity (corresponding to one of the pub keys in ) should be configured manually via flag or env var
            '';
          };

          masterIdentityPubKey = mkOption {
            type = types.str;

            description = ''
              The public key of the master identity to encrypt against. If the masterIdentityFile includes a comment of the form `Recipient: <age-recipient>`,
              the pub key will be inferred automatically. This is the case for all yubikey identities generated by `age-plugin-yubikey`.
            '';
          };

          extraEncryptionPubkeys = mkOption {
            type = with types; listOf (coercedTo path toString str);

            description = ''
              Extra public keys to encrypt for. It is recommended to encrypt against atleast one extra key for disaster recovery purposes.
              If the coerced value of an element is an absolute path, attempt to automatically extract an embedded recipient of the form `Recipient: <age-recipient>`
              (like yubikey identities generated by `age-plugin-yubikey`), if none is found, the file will be treated as a recipient file.

              Warning: Do not use non-split, non-encrypted identity files, even if they have an embedded recipient, you will leak your private key to the nix store!
              (see description of masterIdentityPubKey)
            '';
          };

          passageStoreDir = mkOption {
            type = with types; coercedTo path toString str;

            description = ''
              Path to the passage store relative to the flake root. For the home-manager module this is used to construct a store path.
              For the devShell module it creates a shellHook that points passage at the store inside the flake src
            '';

            default = "/secrets/passage";
          };
        };
      };
    });
  in
  {
    home-manager-module = ({config, pkgs, lib, ...}:

      let
        common = mkCommon {
          inherit pkgs;
          inherit lib;
        };

        # Merge the closure configuration and the config from argument
        cfg = { secrets } // config.secrets;
      in
    {
      options = common.options;

      config = mkIf cfg.enable{
        home.packages = with pkgs;[

          # Allow using yubikey as age identity
          pkgs.age-plugin-yubikey

          passage-wrapped
          # When passage is used in the background as a password command, ensure that a visible popup happens to prompt for yubikey interaction
          pinentry-gnome3
        ];
      }
    });
  }
